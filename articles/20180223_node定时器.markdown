### 0. 引言
下面五行代码的执行结果是什么？
```
setTimeout(() => console.log(1));
setImmediate(() => console.log(2));
process.nextTick(() => console.log(3));
Promise.resolve().then(() => console.log(4));
(() => console.log(5))();
```
### 1. 同步先于异步
第五行是同步代码，前四行是异步代码，所以先打印`5`

### 2. 本轮循环和次轮循环
异步任务分为`本轮循环`和`次论循环`，顾名思义，本轮循环就是异步任务结束时在本轮循环中执行，次论循环是异步任务结束时在次轮循环中执行。

```
Node 规定，process.nextTick和Promise的回调函数，追加在本轮循环，即同步任务一旦执行完成，就开始执行它们。
而setTimeout、setInterval、setImmediate的回调函数，追加在次轮循环。
```

所以，3和4先于1和2打印。

### 3. process.nextTick
名字有些误解，它是在本轮循环执行的，而且是所有异步任务里面最快执行的。所以3先于4打印。

### 4. 微任务（microtask）
process.nextTick的异步任务在队列`nextTickQueue`中。Promise的异步任务在队列`microTaskQueue`中，前一个队列执行完才会执行后一个队列。如下面的代码：
```
process.nextTick(() => console.log(1));
Promise.resolve().then(() => console.log(2));
process.nextTick(() => console.log(3));
Promise.resolve().then(() => console.log(4));
```
执行结果是`1 3 2 4`

### 5. 事件循环(event loop)
js只有一个线程就是主线程，异步任务也是在主线程中执行的。

事件循环的六个阶段
```
timers
I/O callbacks
idle, prepare
poll
check
close callbacks
```

#### 5.1 timers
timers阶段会处理setTimeout和setInterval

#### 5.2 i/o callbacks
除了以下操作的回调函数，其他的回调函数都在这个阶段执行。
```
setTimeout()和setInterval()的回调函数
setImmediate()的回调函数
用于关闭请求的回调函数，比如socket.on('close', ...)
```

### 5.3 idle,prepare
框架操作，略

#### 5.4 poll(轮询)
这个阶段是轮询时间，用于等待还未返回的 I/O 事件，比如服务器的回应、用户移动鼠标等等。

这个阶段的时间会比较长。如果没有其他异步任务要处理（比如到期的定时器），会一直停留在这个阶段，等待 I/O 请求返回结果。

#### 5.5 check
处理setImmediate

#### 5.6 close callbacks
该阶段执行关闭请求的回调函数，比如socket.on('close', ...)。

### 6. 事件循环的例子
```
const fs = require('fs');

const timeoutScheduled = Date.now();

// 异步任务一：100ms 后执行的定时器
setTimeout(() => {
  const delay = Date.now() - timeoutScheduled;
  console.log(`${delay}ms`);
}, 100);

// 异步任务二：至少需要 200ms 的文件读取
fs.readFile('test.js', () => {
  const startCallback = Date.now();
  while (Date.now() - startCallback < 200) {
    // 什么也不做
  }
});
```
脚本进入第一轮事件循环以后，没有到期的定时器，也没有已经可以执行的 I/O 回调函数，所以会进入 Poll 阶段，等待内核返回文件读取的结果。由于读取小文件一般不会超过 100ms，所以在定时器到期之前，Poll 阶段就会得到结果，因此就会继续往下执行。

第二轮事件循环，依然没有到期的定时器，但是已经有了可以执行的 I/O 回调函数，所以会进入 I/O callbacks 阶段，执行fs.readFile的回调函数。这个回调函数需要 200ms，也就是说，在它执行到一半的时候，100ms 的定时器就会到期。但是，必须等到这个回调函数执行完，才会离开这个阶段。

第三轮事件循环，已经有了到期的定时器，所以会在 timers 阶段执行定时器。最后输出结果大概是200多毫秒。

### 7. setTimeout 和 setImmediate
由于setTimeout在 timers 阶段执行，而setImmediate在 check 阶段执行。所以，setTimeout会早于setImmediate完成。
```
setTimeout(() => console.log(1));
setImmediate(() => console.log(2));
```
但实际情况是有时候2会先打印，那是因为setTimeout的第二个参数默认是0，其实际值肯定不是0，而是1毫秒到2147483647毫秒之间。也就是说，setTimeout(f, 0)等同于setTimeout(f, 1)。

实际执行的时候，进入事件循环以后，有可能到了1毫秒，也可能还没到1毫秒，取决于系统当时的状况。如果没到1毫秒，那么 timers 阶段就会跳过，进入 check 阶段，先执行setImmediate的回调函数。

但是，下面的代码一定是先输出2，再输出1。
```
const fs = require('fs');

fs.readFile('test.js', () => {
  setTimeout(() => console.log(1));
  setImmediate(() => console.log(2));
});
```
上面代码会先进入 I/O callbacks 阶段，然后是 check 阶段，最后才是 timers 阶段。因此，setImmediate才会早于setTimeout执行。

### 8. 其他
setImmediate和process.nextTick是node的方法。
### 9. 参考文章
[阮一峰-Node 定时器详解](http://www.ruanyifeng.com/blog/2018/02/node-event-loop.html)


